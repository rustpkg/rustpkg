// Copyright 2012 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// rustpkg - a purely function package manager and build system

#[link(name = "rustpkg",
       vers = "0.6",
       uuid = "25de5e6e-279e-4a20-845c-4cabae92daaf",
       url = "https://github.com/mozilla/rust/tree/master/src/librustpkg")];

#[crate_type = "lib"];
#[no_core];
#[allow(vecs_implicitly_copyable,
        non_implicitly_copyable_typarams)];

extern mod core(vers = "0.6");
extern mod std(vers = "0.6");
extern mod rustc(vers = "0.6");
extern mod syntax(vers = "0.6");

use core::*;
use io::{ReaderUtil, WriterUtil};
use std::getopts;
use rustc::metadata::{filesearch};
use syntax::{ast, codemap, parse, visit, attr};
use semver::Version;

mod api;
mod usage;
mod util;

struct PackageScript {
    id: ~str,
    name: ~str,
    vers: Version,
    crates: ~[~str],
    deps: ~[(~str, Option<~str>)]
}

impl PackageScript {
    static fn parse(parent: Path) -> PackageScript {
        let script = parent.push(~"package.rs");

        if !os::path_exists(&script) {
            fail ~"no package.rs file";
        }

        let sess = parse::new_parse_sess(None);
        let crate = parse::parse_crate_from_file(&script, ~[], sess);
        let mut id = None;
        let mut vers = None;
        let mut crates = ~[];
        let mut deps = ~[];

        fn load_pkg_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,
                                                      Option<~str>) {
            let mut id = None;
            let mut vers = None;

            for mis.each |a| {
                match a.node {
                    ast::meta_name_value(v, ast::spanned {
                                                node: ast::lit_str(s),
                                                span: _}) => {
                        match v {
                            ~"id" => id = Some(*s),
                            ~"vers" => vers = Some(*s),
                            _ => ()
                        }
                    }
                    _ => {}
                }
            }

            (id, vers)
        }

        fn load_pkg_dep_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,
                                                          Option<~str>) {
            let mut url = None;
            let mut target = None;

            for mis.each |a| {
                match a.node {
                    ast::meta_name_value(v, ast::spanned {
                                                node: ast::lit_str(s),
                                                span: _}) => {
                        match v {
                            ~"url" => url = Some(*s),
                            ~"target" => target = Some(*s),
                            _ => ()
                        }
                    }
                    _ => {}
                }
            }

            (url, target)
        }

        fn load_pkg_crate_attr(mis: ~[@ast::meta_item]) -> Option<~str> {
            let mut file = None;

            for mis.each |a| {
                match a.node {
                    ast::meta_name_value(v, ast::spanned {
                                                node: ast::lit_str(s),
                                                span: _}) => {
                        match v {
                            ~"file" => file = Some(*s),
                            _ => ()
                        }
                    }
                    _ => {}
                }
            }

            file
        }

        for crate.node.attrs.each |a| {
            match a.node.value.node {
                ast::meta_list(v, mis) => {
                    match v {
                        ~"pkg" => {
                            let (i, v) = load_pkg_attr(mis);

                            id = i;
                            vers = v;
                        }
                        ~"pkg_dep" => {
                            let (u, t) = load_pkg_dep_attr(mis);

                            if u.is_none() {
                                fail ~"pkg_dep attr without a url value";
                            }

                            deps.push((u.get(), t));
                        }
                        ~"pkg_crate" => {
                            let f = load_pkg_crate_attr(mis);

                            if f.is_none() {
                                fail ~"pkg_file attr without a file value";
                            }

                            crates.push(f.get());
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }

        if id.is_none() || vers.is_none() {
            fail ~"id or vers isn't defined in a pkg attribute in package.rs";
        }

        let id = id.get();
        let vers = vers.get();

        PackageScript {
            id: id,
            name: util::parse_id(id),
            vers: util::parse_vers(vers),
            crates: crates,
            deps: deps
        }
    }

    fn hash() -> ~str {
        let hasher = hash::default_state();

        hasher.write_str(self.id + self.vers.to_str());

        fmt!("%s-%s-%s", self.name, hasher.result_str(), self.vers.to_str())
    }

    fn work_dir() -> Path {
        util::root().push(~"work").push(self.hash())
    }
}

struct Ctx {
    cfgs: ~[~str],
    prefer: bool
}

impl Ctx {
    fn run(cmd: ~str, args: ~[~str]) {
        let root = util::root();

        util::need_dir(&root);
        util::need_dir(&root.push(~"work"));
        util::need_dir(&root.push(~"lib"));
        util::need_dir(&root.push(~"bin"));
        util::need_dir(&root.push(~"tmp"));

        match cmd {
            ~"build" => self.build(args),
            ~"clean" => self.clean(args),
            ~"install" => self.install(args),
            ~"prefer" => self.prefer(args),
            ~"test" => self.test(args),
            ~"uninstall" => self.uninstall(args),
            ~"unprefer" => self.unprefer(args),
            _ => fail ~"reached an unhandled command"
        };
    }

    fn build(_args: ~[~str]) -> bool {
        let script = PackageScript::parse(os::getcwd());
        let dir = script.work_dir();
        let mut success = true;

        util::need_dir(&dir);
        util::info(fmt!("building %s v%s (%s)", script.name, script.vers.to_str(),
                                                script.id));

        if script.deps.len() >= 1 {
            util::info(~"installing dependencies..");

            for script.deps.each |&dep| {
                let (url, target) = dep;

                success = self.install(if target.is_none() { ~[url] }
                                       else { ~[url, target.get()] });

                if !success { break; }
            }

            if !success {
                util::error(fmt!("building %s v%s failed: a dep wasn't installed",
                                 script.name, script.vers.to_str()));

                return false;
            }

            util::info(~"installed dependencies");
        }

        for script.crates.each |&crate| {
            success = self.compile(&dir, crate, ~[]);

            if !success { break; }
        }

        if !success {
            util::error(fmt!("building %s v%s failed: a crate failed to compile",
                             script.name, script.vers.to_str()));

            return false;
        }

        util::info(fmt!("built %s v%s", script.name, script.vers.to_str()));

        true
    }

    fn compile(dir: &Path, crate: ~str, flags: ~[~str]) -> bool {
        util::info(~"compiling " + crate);

        true
    }

    fn clean(_args: ~[~str]) -> bool {
        let script = PackageScript::parse(os::getcwd());
        let dir = script.work_dir();

        util::info(fmt!("cleaning %s v%s (%s)", script.name, script.vers.to_str(),
                                                script.id));

        if os::path_is_dir(&dir) {
            if os::remove_dir(&dir) {
                util::info(fmt!("cleaned %s v%s", script.name,
                                                  script.vers.to_str()));
            } else {
                util::error(fmt!("cleaning %s v%s failed",
                                 script.name, script.vers.to_str()));
            }
        } else {
            util::info(fmt!("cleaned %s v%s", script.name,
                                              script.vers.to_str()));
        }

        true
    }

    fn install(args: ~[~str]) -> bool {
        let mut success;
        let mut dir;

        if args.len() < 1 {
            util::info(~"installing from the cwd");

            dir = os::getcwd();

            return true;
        } else {
            let url = args[0];
            let target = if args.len() >= 2 { Some(args[1]) }
                         else { None };
            let hasher = hash::default_state();

            hasher.write_str(url);

            if !target.is_none() {
                hasher.write_str(target.get());
            }

            dir = util::root().push(~"tmp").push(hasher.result_str());
            success = self.fetch(&dir, url, target);

            if !success {
                return false;
            }
        }

        let script = PackageScript::parse(dir);
        dir = script.work_dir();

        util::info(fmt!("installing %s v%s (%s)", script.name, script.vers.to_str(),
                                                  script.id));

        if script.deps.len() >= 1 {
            util::info(~"installing dependencies..");

            for script.deps.each |&dep| {
                let (url, target) = dep;

                success = self.install(if target.is_none() { ~[url] }
                                       else { ~[url, target.get()] });

                if !success { break; }
            }

            if !success {
                util::error(fmt!("installing %s v%s failed: a dep wasn't installed",
                                 script.name, script.vers.to_str()));
                return false;
            }

            util::info(~"installed dependencies");
        }

        for script.crates.each |&crate| {
            success = self.compile(&dir, crate, ~[]);

            if !success { break; }
        }

        if !success {
            util::error(fmt!("installing %s v%s failed: a crate failed to compile",
                             script.name, script.vers.to_str()));
            return false;
        }

        util::info(fmt!("installed %s v%s", script.name,
                                            script.vers.to_str()));

        true
    }

    fn fetch(dir: &Path, url: ~str, target: Option<~str>) -> bool {
        util::info(fmt!("installing from %s", url));

        true
    }

    fn prefer(_args: ~[~str]) -> bool {
        true
    }

    fn test(_args: ~[~str]) -> bool {
        true
    }

    fn uninstall(_args: ~[~str]) -> bool {
        true
    }

    fn unprefer(_args: ~[~str]) -> bool {
        true
    }
}

pub fn main() {
    let args = os::args();
    let opts = ~[getopts::optflag(~"h"), getopts::optflag(~"help"),
                 getopts::optmulti(~"c"), getopts::optmulti(~"cfg"),
                 getopts::optmulti(~"p"), getopts::optmulti(~"prefer")];
    let matches = &match getopts::getopts(args, opts) {
        result::Ok(m) => m,
        result::Err(f) => {
            fail fmt!("%s", getopts::fail_str(f));
        }
    };
    let help = getopts::opt_present(matches, ~"h") ||
               getopts::opt_present(matches, ~"help");
    let cfgs = vec::append(getopts::opt_strs(matches, ~"cfg"),
                           getopts::opt_strs(matches, ~"c"));
    let prefer = getopts::opt_present(matches, ~"p") ||
                 getopts::opt_present(matches, ~"prefer");
    let mut args = copy matches.free;

    args.shift();

    if (args.len() < 1) {
        return usage::general();
    }

    let cmd = args.shift();

    if !util::is_cmd(cmd) {
        return usage::general();
    } else if help {
        return match cmd {
            ~"build" => usage::build(),
            ~"clean" => usage::clean(),
            ~"install" => usage::install(),
            ~"prefer" => usage::prefer(),
            ~"test" => usage::test(),
            ~"uninstall" => usage::uninstall(),
            ~"unprefer" => usage::unprefer(),
            _ => usage::general()
        };
    }

    Ctx {
        cfgs: cfgs,
        prefer: prefer
    }.run(cmd, args);
}

pub use Crate = api::Crate;
pub use build = api::build;
pub use util = api::util;
